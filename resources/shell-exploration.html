<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="Peter McCormick">

        <title>CSC209 Summer 2015 &mdash; Exploring with the Shell</title>

        <link href="../theme/css/pygment.css" rel="stylesheet">
        <!-- Bootstrap core CSS -->
        <link href="../theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom styles for this template -->
        <link href="../theme/css/style.css" rel="stylesheet">


        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
              <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
              <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
            <![endif]-->
    </head>
    <body>
        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="..">CSC209 Summer 2015</a>
                </div>
                <div id="navbar" class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li><a href="../syllabus.html">Syllabus</a></li>
                        <li><a href="../lectures.html">Lectures</a></li>
                        <li><a href="../assignments.html">Assignments</a></li>
                        <li><a href="../labs.html">Labs</a></li>
                        <li><a href="../tests.html">Tests</a></li>
                        <li><a href="../resources.html">Resources</a></li>
                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Links <span class="caret"></span></a>
                            <ul class="dropdown-menu" role="menu">
                                <li><a href="feedback.html">Anonymous Feedback</a></li>
                                <li><a href="https://piazza.com/utoronto.ca/summer2015/csc209">Piazza</a></li>
                                <li><a href="https://markus.cdf.toronto.edu/csc209-2015-05/">MarkUs</a></li>
                                <li><a href="https://www.cdf.toronto.edu/students/">CDF Grades</a></li>
                                <li><a href="http://www.cdf.toronto.edu/~csc209h/winter/lectures.html">CSC209 Winter 2015</a></li>
                            </ul>
                        </li>
                    </ul>
                </div><!--/.nav-collapse -->
            </div>
        </nav>
        <div class="container">
    <div class="page-header">
    <h1>Exploring with the Shell</h1>
</div>

<div class="toc">
<ul>
<li><a href="#the-prompt">The Prompt</a></li>
<li><a href="#cd-change-directory">cd - change directory</a></li>
<li><a href="#pwd-print-name-of-working-directory">pwd - print name of working directory</a></li>
<li><a href="#ls-list-directory-contents">ls - list directory contents</a></li>
<li><a href="#ls-l-list-using-long-listing-format">ls -l - list using long listing format</a></li>
<li><a href="#mkdir-make-directory">mkdir - make directory</a></li>
<li><a href="#rmdir-remove-directory">rmdir - remove directory</a></li>
<li><a href="#touch-change-file-timestamps-also-creates-new-empty-files">touch - change file timestamps (also creates new empty files)</a></li>
<li><a href="#rm-remove-file">rm - remove file</a></li>
<li><a href="#mv-moverename-files-and-directories">mv - move/rename files and directories</a></li>
<li><a href="#cp-copy-file-and-directories">cp - copy file and directories</a></li>
<li><a href="#echo-and-output-redirection">echo and output redirection</a></li>
<li><a href="#a-comment-about-standard-output">A Comment about Standard Output</a></li>
<li><a href="#cat-concatenate-files-and-print-on-the-standard-output">cat - concatenate files and print on the standard output</a></li>
<li><a href="#grep-print-lines-matching-a-pattern">grep - print lines matching a pattern</a></li>
<li><a href="#pipes">Pipes</a></li>
</ul>
</div>
<h2 id="the-prompt">The Prompt</h2>
<p>When you login to a remote Linux server like CDF, after some introductory text
(called the <em>message of the day</em>), the last line you will be left with is
called the <em>shell prompt</em>.</p>
<p>If your prompt looks like <code>wolf:~%</code> (specifically the "%" at the end), you are
currently running the "tcsh" shell. Type <code>bash</code> and hit enter to start the Bash
shell, which we will be assuming you are using from here on. You can use the
<code>chsh</code> command to make this change permanent for future logins.</p>
<p>Assuming you are running Bash, you should see a prompt that looks like
<code>wolf:~$</code>, followed by the blinking cursor where the commands you are typing
will appear. At a glance, this prompt tells us two things. First, the name of
the remote machine is "wolf", and second, that our current working directory is
"~", which is shorthand for your <em>home directory</em>.</p>
<p>Any time you are using the shell, the commands you enter will be run relative
to the files in the <em>present working directory</em>. First, let's learn how to
change the working directory.</p>
<h2 id="cd-change-directory">cd - change directory</h2>
<p>A <em>filesystem</em> is a mechanism for organizing your data on some kind of
persistent storage device like a spinning magnetic disk or solid state drive.
Typically they are structured as a tree or directed graph with named nodes,
with <em>files</em> containing the actual data and <em>directories</em> (sometimes referred
to as <em>folders</em>) containing both files and other sub-directories.</p>
<p>On any Unix system, the <em>root directory</em>, or <code>/</code>, is the highest point on the
filesystem tree. You can change to it by running <code>cd /</code>. Notice that your
prompt will change to reflect the new <em>working directory</em>:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span>
</pre></div>


<p>Now, instead of your home directory ~, you are at /.</p>
<p>A <em>path</em> that begins with a forward slash <code>/</code> is said to be <em>absolute</em>, because
it is not relative to any other location (such as your working directory.) The
path <code>~</code> is similarly understood to be absolute because it's meaning does not
change.</p>
<p>By using an absolute path, we unambiguously change to the exact directory we are
interested in.</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span> /usr/local/bin
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> ~
<span class="gp">wolf:~$</span> <span class="nb">cd</span> /usr/local/bin
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span>
</pre></div>


<p>In this example, the <code>/usr/local/bin</code> directory is a system-provided directory
that includes locally installed, user accessible 'binaries', which is a Unix-y
term for programs.</p>
<p>A <em>relative path</em> is one which is relative to the current working directory.
Consider the command <code>cd bin</code>: depending on whether a directory named "bin"
even exists in the working directory, the result of executing this command
will certainly be a change to a new working directory, but to exactly which one
will depend on the initial working directory. A Unix system typically has
several different "bin" directories that live in different places:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd </span>bin
<span class="gp">wolf:/bin$</span> <span class="nb">cd</span> /usr/local
<span class="gp">wolf:/usr/local$</span> <span class="nb">cd </span>bin
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> /usr
<span class="gp">wolf:/usr$</span> <span class="nb">cd </span>bin
<span class="gp">wolf:/usr/bin$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span>
</pre></div>


<p>In this case, we ran the same command, <code>cd bin</code>, three different times, with
the net result of each being a change in working directory to "bin" directories
that each have a different absolute path location: <code>/bin</code>, <code>/usr/bin</code> and
<code>/usr/local/bin</code>.</p>
<p>One nice feature of the <code>cd</code> command is that, if you simply run it without any
arguments, it will change you back to your home directory:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span>
<span class="gp">wolf:~$</span>
</pre></div>


<p>Every directory in the filesystem contains two special entries named <code>.</code> and
<code>..</code>. The <code>.</code> entry in a directory is actually a <em>link</em> to that same directory,
while <code>..</code> is a <em>link</em> to a parent directory. By using <code>..</code> we can more easily
creep our way upwards in the filesystem tree, towards the root directory.
Instead of being forced to use absolute paths like this:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> <span class="nb">cd</span> /usr/local/bin/X11
<span class="gp">wolf:/usr/local/bin/X11$</span> <span class="nb">cd</span> /usr/local/bin
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> /usr/local/
<span class="gp">wolf:/usr/local$</span> <span class="nb">cd</span> /usr/
<span class="gp">wolf:/usr$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span>
</pre></div>


<p>Rather, we can save some typing and do this:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span> /usr/local/bin/X11
<span class="gp">wolf:/usr/local/bin/X11$</span> <span class="nb">cd</span> ..
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> ..
<span class="gp">wolf:/usr/local$</span> <span class="nb">cd</span> ..
<span class="gp">wolf:/usr$</span> <span class="nb">cd</span> ..
<span class="gp">wolf:/$</span>
</pre></div>


<p>Your shell will remember a history of commands you have previously entered, so
us the up/down arrows to navigate through those and saving yourself even more
typing.</p>
<p>Using a relative path that begins with <code>.</code> may seem redundant, because any
relative path is precisely that because it is relative to the current working
directory, and the <code>.</code> simply refers to the same current working directory, but
it will become useful again later:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span> ./usr
<span class="gp">wolf:/usr$</span> <span class="nb">cd</span> ./local
<span class="gp">wolf:/usr/local$</span> <span class="nb">cd</span> ./bin
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> .
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> ./.
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> ./././
<span class="gp">wolf:/usr/local/bin$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span>
</pre></div>


<p>Combining all of these together can yield some rather convoluted path
expressions:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span> /usr/local/bin/../bin/../../local/../../bin
<span class="gp">wolf:/bin$</span>
</pre></div>


<h2 id="pwd-print-name-of-working-directory"><code>pwd</code> - print name of working directory</h2>
<p>Although the shell prompt will show us the current working directory, it's
useful to be able to confirm this using the <code>pwd</code> command:</p>
<div class="highlight"><pre><span class="gp">wolf:/bin$</span> <span class="nb">pwd</span>
<span class="go">/bin</span>
<span class="gp">wolf:/bin$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span> <span class="nb">pwd</span>
<span class="go">/</span>
<span class="gp">wolf:/$</span>
</pre></div>


<p>So where exactly is our own personal home directory?</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> <span class="nb">cd</span>
<span class="gp">wolf:~$</span><span class="nb"> pwd</span>
<span class="go">/h/u5/g5/00/g5peterm</span>
<span class="gp">wolf:~$</span>
</pre></div>


<p>While the specific path of your home directory will be different, we can
clearly see that <code>~</code> is not a real path but is instead a shorthand for a
specific absolute path. This notation is provided to us by the shell for our
convenience.</p>
<p>Now that we have a good handle on absolute and relative paths, and changing
directories, let's actually look at how we can find out what they contain.</p>
<h2 id="ls-list-directory-contents">ls - list directory contents</h2>
<p>So far we've learned to navigate around known directory structures, but we have
not yet learned how to really explore into the unknown. The most used tool for
this is <code>ls</code>, which will show all the files and directories contained within
the working directory:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> <span class="nb">cd</span> /h
<span class="gp">wolf:/h$</span> ls
<span class="go">u0  u1  u10  u11  u12  u13  u14  u15  u16  u17  u2  u3  u4  u5  u6  u7  u8  u9</span>
</pre></div>


<p>From this can have learned that this system has directories named "/h/u0",
"/h/u1" and so forth. We can also ask <code>ls</code> to list for a specific path (which
can be either relative or absolute):</p>
<div class="highlight"><pre><span class="gp">wolf:/h$</span> ls u5
<span class="go">RESTORE      c0  c2  c4  c6  c8  g0  g2  g4  g6  g8  lost+found  t0  t2  t4  t6  t8</span>
<span class="go">aquota.user  c1  c3  c5  c7  c9  g1  g3  g5  g7  g9  quotas      t1  t3  t5  t7  t9</span>
</pre></div>


<p>Under /h/u5 there is further structure, although it is not immediately obvious
what these names represent: are they files, or are they directories? If we try
to <code>cd</code> to a name that actually turns out to be a file, Bash will inform us
with an error:</p>
<div class="highlight"><pre><span class="gp">wolf:/h$</span> <span class="nb">cd </span>u5/quotas
<span class="go">-bash: cd: u5/quotas: Not a directory</span>
<span class="gp">wolf:/h$</span>
</pre></div>


<p>One way to help us learn this from the output of <code>ls</code> directly is to switch
away from a horizontal display to a vertical, or "long", listing mode.</p>
<h2 id="ls-l-list-using-long-listing-format"><code>ls -l</code> - list using long listing format</h2>
<p>By passing in the "-l" argument, ls will show us a lot more information:</p>
<div class="highlight"><pre><span class="gp">wolf:/h$</span> <span class="nb">cd</span> /
<span class="gp">wolf:/$</span> ls -l
<span class="go">total 256</span>
<span class="go">drwxr-xr-x   2 root root       4096 Feb 11 08:05 bin</span>
<span class="go">drwxr-x---   3 root cdfstaff   4096 Apr 30 17:50 boot</span>
<span class="go">drwxr-xr-x  14 root root       4520 May 15 00:03 dev</span>
<span class="go">drwxr-xr-x 175 root root      12288 May 15 00:34 etc</span>
<span class="go">drwxr-xr-x  20 root root          0 May 11 14:56 h</span>
<span class="go">drwxr-xr-x   2 root root       4096 Apr 19  2012 home</span>
<span class="go">drwxr-xr-x  20 root root       4096 Apr 28 16:10 lib</span>
<span class="go">drwxr-xr-x  18 root root       4096 Dec 19 11:16 local</span>
<span class="go">drwx------   2 root root      16384 Dec 16 14:56 lost+found</span>
<span class="go">drwxr-xr-x   2 root root       4096 Apr 19  2012 mnt</span>
<span class="go">drwxr-xr-x   3 root root       4096 Dec 16 15:44 opt</span>
<span class="go">dr-xr-xr-x 672 root root          0 Apr 30 12:08 proc</span>
<span class="go">drwx------   5 root root       4096 Apr 30 11:53 root</span>
<span class="go">drwxr-xr-x   2 root root      12288 May 11 12:17 sbin</span>
<span class="go">dr-xr-xr-x  13 root root          0 Apr 30 12:08 sys</span>
<span class="go">drwxrwxrwt  26 root root     143360 May 15 02:25 tmp</span>
<span class="go">drwxr-xr-x  14 root root       4096 Dec 16 16:21 usr</span>
<span class="go">drwxr-xr-x  23 root root       4096 May 14 22:38 var</span>
</pre></div>


<p>In the root directory, all the entry names (shown here in the far right column)
are themselves sub-directories, as indicated by the left-most <code>d</code> character.
The first column represent the file access permission bits (explained later),
the third and fourth represent the user and group that are considered to own
the file, and the date and time the last-modified timestamp. The numeric second
and fifth columns indicate the number of internal filesystem links and the size
of the entry in terms of bytes of storage, respectively.</p>
<p>Back to the earlier name that was a file and not a directory:</p>
<div class="highlight"><pre><span class="gp">wolf:/$</span> ls -l /h/u5/quotas
<span class="go">-rw------- 1 root root 391424 Aug 20  2010 /h/u5/quotas</span>
</pre></div>


<p>The left-most <code>-</code> means it is <em>not</em> a directory, and here the size of 391424
bytes is the exact size of this file (for directories, the reported size
corresponds with how many entries are contained within it and how much it space
on disk it takes to represent that is some filesystem-specific binary format.)</p>
<p>Next, let's start to create our own directories and files.</p>
<h2 id="mkdir-make-directory"><code>mkdir</code> - make directory</h2>
<p>Let's change to our home directory and then make two directories, one inside the other:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> mkdir learn
<span class="gp">wolf:~$</span> <span class="nb">cd </span>learn
<span class="gp">wolf:~/learn$</span> mkdir subdir
<span class="gp">wolf:~/learn$</span> ls -l
<span class="go">total 4</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 02:38 subdir</span>
</pre></div>


<p>We've created the directory <code>~/learn/subdir</code>. Instead of "pdm" and "instrs" as the
user that owns the file and the group associated with it, you will see your CDF
username and typically either "cstudent" or "gstudent" as the group.</p>
<h2 id="rmdir-remove-directory"><code>rmdir</code> - remove directory</h2>
<p>First let's attempt to remove the ~/learn directory:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> rmdir learn
<span class="go">rmdir: failed to remove `learn&#39;: Directory not empty</span>
</pre></div>


<p>Generally speaking, we can only remove empty directories.</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> rmdir learn/subdir/
<span class="gp">wolf:~$</span> rmdir learn/
<span class="gp">wolf:~$</span> ls -l learn
<span class="go">ls: cannot access learn: No such file or directory</span>
</pre></div>


<p>Both ~/learn/subdir and ~/learn have been removed.</p>
<p>Now let's start creating files.</p>
<h2 id="touch-change-file-timestamps-also-creates-new-empty-files"><code>touch</code> - change file timestamps (also creates new empty files)</h2>
<p>The <code>touch</code> command will create an empty file if the name does not already exist:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> mkdir learn
<span class="gp">wolf:~$</span> <span class="nb">cd </span>learn
<span class="gp">wolf:~/learn$</span> touch newfile
<span class="gp">wolf:~/learn$</span> ls -l newfile
<span class="go">-rw------- 1 pdm instrs 0 May 15 02:51 newfile</span>
</pre></div>


<p>By default, the created file will have as its last-modified timestamp the time
at which it was created. If you <code>touch</code> a file that already exists, it will
simply update that timestamp to the present time. So, after letting at least a
minute or two has pass:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> ls -l newfile
<span class="go">-rw------- 1 pdm instrs 0 May 15 02:51 newfile</span>
<span class="gp">wolf:~/learn$</span> touch newfile
<span class="gp">wolf:~/learn$</span> ls -l newfile
<span class="go">-rw------- 1 pdm instrs 0 May 15 02:53 newfile</span>
</pre></div>


<p>Although this file is empty (it has a file size of 0 bytes), it is still a
legitimate file complete with a name, owner/group, timestamps and permission
bits.</p>
<h2 id="rm-remove-file"><code>rm</code> - remove file</h2>
<p>Let's delete this file:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> rm newfile
<span class="go">rm: remove regular empty file `newfile&#39;? y</span>
</pre></div>


<p>You can also delete more than one file at a time:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> touch file1 file2
<span class="gp">wolf:~/learn$</span> ls -l file1 file2
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:00 file1</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:00 file2</span>
<span class="gp">wolf:~/learn$</span> rm file1 file2
<span class="go">rm: remove regular empty file `file1&#39;? y</span>
<span class="go">rm: remove regular empty file `file2&#39;? y</span>
<span class="gp">wolf:~/learn$</span> ls -l file1 file2
<span class="go">ls: cannot access file1: No such file or directory</span>
<span class="go">ls: cannot access file2: No such file or directory</span>
</pre></div>


<h2 id="mv-moverename-files-and-directories"><code>mv</code> - move/rename files and directories</h2>
<p>Now that we can create directories and rudimentary (empty) files, we should
also learn how to rename them. First, we'll touch one file named "oldfile" and
we note that there is no file (yet) named "newfile":</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> touch oldfile
<span class="gp">wolf:~$</span> ls -l oldfile newfile
<span class="go">ls: cannot access newfile: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 14 23:59 oldfile</span>
</pre></div>


<p>Then we use <code>mv <em>source</em> <em>destination</em></code> to rename "oldfile" to "newfile":</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> mv oldfile newfile
<span class="gp">wolf:~$</span> ls -l oldfile newfile
<span class="go">ls: cannot access oldfile: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 14 23:59 newfile</span>
</pre></div>


<p>And then we effectively undo the first rename by renaming "newfile" back to "oldfile":</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> mv newfile oldfile
<span class="gp">wolf:~$</span> ls -l oldfile newfile
<span class="go">ls: cannot access newfile: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 14 23:59 oldfile</span>
</pre></div>


<p>We can just as easily rename directories. In this example, directory "a" is renamed to "b":</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> mkdir a
<span class="gp">wolf:~/learn$</span> ls -l
<span class="go">total 4</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:05 a</span>
<span class="gp">wolf:~/learn$</span> mv a b
<span class="gp">wolf:~/learn$</span> ls -l
<span class="go">total 4</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:05 b</span>
</pre></div>


<p>Finally, <code>mv</code> can be used, as its name suggests, to move files and directories
around, beyond just within a single directory:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> mkdir a b
<span class="gp">wolf:~/learn$</span> ls -l a/foo
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:10 a/foo</span>
<span class="gp">wolf:~/learn$</span> mv a/foo b/
<span class="gp">wolf:~/learn$</span> ls -l a/foo b/foo
<span class="go">ls: cannot access a/foo: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:10 b/foo</span>
<span class="gp">wolf:~/learn$</span> mv b/foo a/bar
<span class="gp">wolf:~/learn$</span> ls -l b/foo a/bar
<span class="go">ls: cannot access b/foo: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:10 a/bar</span>
</pre></div>


<p>When moving a directory, we are potentially replanting an entire sub-tree of directories:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> mkdir -p x/y/z
<span class="gp">wolf:~/learn$</span> ls -l -R
<span class="go">.:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 3 pdm instrs 4096 May 15 03:15 x</span>

<span class="go">./x:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 3 pdm instrs 4096 May 15 03:15 y</span>

<span class="go">./x/y:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:15 z</span>

<span class="go">./x/y/z:</span>
<span class="go">total 0</span>
<span class="gp">wolf:~/learn$</span> mv x foo
<span class="gp">wolf:~/learn$</span> ls -l -R
<span class="go">.:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 3 pdm instrs 4096 May 15 03:15 foo</span>

<span class="go">./foo:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 3 pdm instrs 4096 May 15 03:15 y</span>

<span class="go">./foo/y:</span>
<span class="go">total 4</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:15 z</span>

<span class="go">./foo/y/z:</span>
<span class="go">total 0</span>
</pre></div>


<p>Where <code>mkdir -p x/y/z</code> creates all required intermediate parent directories
(instead of separately running <code>mkdir x</code>, <code>mkdir x/y</code> and <code>mkdir x/y/z</code>), and
the <code>-R</code> flag argument will cause <code>ls</code> to recursively list the contents of all
enclosing sub-directories.</p>
<p>In this sense, a rename of a file or directory named "src" to "dest" can be seen as merely moving "./src" to "./dest": <em>the act of renaming is really just the act of moving</em>.</p>
<h2 id="cp-copy-file-and-directories"><code>cp</code> - copy file and directories</h2>
<p>We can also easily create a duplicate of a file through copying:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> touch foo
<span class="gp">wolf:~/learn$</span> ls -l foo bar
<span class="go">ls: cannot access bar: No such file or directory</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:20 foo</span>
<span class="gp">wolf:~/learn$</span> cp foo bar
<span class="gp">wolf:~/learn$</span> ls -l foo bar
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:20 bar</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:20 foo</span>
</pre></div>


<p>We can copy directory structures recursively with the <code>-R</code> argument:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> mkdir foo
<span class="gp">wolf:~/learn$</span> touch foo/foofile
<span class="gp">wolf:~/learn$</span> cp -R foo bar
<span class="gp">wolf:~/learn$</span> ls -Rl
<span class="go">.:</span>
<span class="go">total 8</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:22 bar</span>
<span class="go">drwx------ 2 pdm instrs 4096 May 15 03:22 foo</span>

<span class="go">./bar:</span>
<span class="go">total 0</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:22 foofile</span>

<span class="go">./foo:</span>
<span class="go">total 0</span>
<span class="go">-rw------- 1 pdm instrs 0 May 15 03:22 foofile</span>
</pre></div>


<h2 id="echo-and-output-redirection"><code>echo</code> and output redirection</h2>
<p>Creating empty files is of limited usefulness. But first, let's see <code>echo</code> in
action:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo </span>hello world
<span class="go">hello world</span>
</pre></div>


<p>The <code>echo</code> command simply repeats (echoes) whatever it was passed as an
argument. Keep in mind that certain non-alphabetical characters such as ! ; &lt; &gt;
&amp; $ # * &#x60; have special meanings in the shell, so if you want to echo them,
you will probably need to wrap them as single quote strings. And only quoted
strings can have more than one consecutive whitespace:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo  </span>hello     world
<span class="go">hello world</span>
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;hello     world&quot;</span>
<span class="go">hello     world</span>
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s1">&#39;hello  world!&#39;</span>
<span class="go">hello  world!</span>
</pre></div>


<p>The utility of <code>echo</code> greatly increases when we combine it with a feature of
the shell called <em>output redirection</em>. This feature let's us take the output of one
program, and save it to a file:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;hello world&quot;</span> &gt; hello.txt
<span class="gp">wolf:~/learn$</span> ls -l hello.txt
<span class="go">-rw------- 1 pdm instrs 12 May 15 03:34 hello.txt</span>
</pre></div>


<p>Now we've finally created a file that is not empty! If you are counting
closely, however, you may wonder how the file size wound up being 12 bytes
while the string "hello world" is only 11 characters long. In this case <code>echo</code>
is also including an ASCII newline character. We can suppress this behaviour
with the <code>-n</code> flag, and the result looks a bit peculiar when used from the
prompt:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> -n <span class="s2">&quot;hello world&quot;</span>
<span class="go">hello worldwolf:~/learn$</span>
</pre></div>


<p>This visual appearance is caused because, after a command is finished, Bash
reprints the prompt, but in this case, since echo was instructed to forego the
trailing newline, the prompt winds up on the same line as its output.</p>
<p>Using this flag, the redirected file size matches our original expectations:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> rm -f hello.txt
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> -n <span class="s2">&quot;hello world&quot;</span> &gt; hello.txt
<span class="gp">wolf:~/learn$</span> ls -l hello.txt
<span class="go">-rw------- 1 pdm instrs 11 May 15 03:39 hello.txt</span>
</pre></div>


<p>We can also use a double arrow <code>&gt;&gt;</code> to <em>append</em> to the end of a file:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Hi&quot;</span> &gt; hello.txt
<span class="gp">wolf:~/learn$</span> ls -l hello.txt
<span class="go">-rw------- 1 pdm instrs 3 May 15 03:59 hello.txt</span>
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Hello&quot;</span> &gt; hello.txt
<span class="go">-bash: hello.txt: cannot overwrite existing file</span>
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Hello&quot;</span> &gt;&gt; hello.txt
<span class="gp">wolf:~/learn$</span> ls -l hello.txt
<span class="go">-rw------- 1 pdm instrs 9 May 15 04:00 hello.txt</span>
</pre></div>


<p>Bash will typically try to not let you overwrite an existing file accidentally,
which would erase its contents.  Either delete it, move it out of the way, or
append.</p>
<h2 id="a-comment-about-standard-output">A Comment about Standard Output</h2>
<p>The key concept to emphasize here is that the <code>echo</code> program did not have to be
written with any special support for output redirection. It operates in the
same manner whether you are using it interactively from the prompt, or if you
are redirecting its output. In either case, it is writing data to its <em>standard
output</em> (also referred to as <em>stdout</em>), and when you ask the Bash shell to
redirect that output with the arrow <code>&gt;</code>, instead of displaying it at the prompt
in the usual fashion, it will directs the contents to a file on disk. </p>
<p>There is also an analogous concept of <em>standard input</em> (<em>stdin</em>), but first,
another useful command.</p>
<h2 id="cat-concatenate-files-and-print-on-the-standard-output"><code>cat</code> - concatenate files and print on the standard output</h2>
<p>If we want to quickly check the contents of a file, we can <code>cat</code> it:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Hello CSC209&quot;</span> &gt; hello.txt
<span class="gp">wolf:~/learn$</span> cat hello.txt
<span class="go">Hello CSC209</span>
</pre></div>


<p>As its name suggests, you can pass in several filenames as arguments to cat and
it will concatenate all of their contents, in order, and print them to standard
out:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Hello&quot;</span> &gt; hello1.txt
<span class="gp">wolf:~/learn$</span> <span class="nb">echo</span> <span class="s2">&quot;Bonjour&quot;</span> &gt; hello2.txt
<span class="gp">wolf:~/learn$</span> cat hello1.txt hello2.txt
<span class="go">Hello</span>
<span class="go">Bonjour</span>
<span class="gp">wolf:~/learn$</span> cat hello2.txt hello1.txt hello2.txt
<span class="go">Bonjour</span>
<span class="go">Hello</span>
<span class="go">Bonjour</span>
</pre></div>


<p>With respect to the concept of standard input, if you omit any filename
arguments at all, cat will appear to hang, seemingly doing nothing and not
returning you to the prompt. Hit <code>CTRL-c</code> to get out of this.</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> cat
<span class="go">^C</span>
<span class="gp">wolf:~/learn$</span>
</pre></div>


<p>What is in fact happening is that cat is waiting for you to provide something
on the <em>standard input</em>. Once you do that, it will print it. Run <code>cat</code> at the
shell, type "Hello world!" (without quotes) and then hit enter; cat will print
your input right back out on its standard output (hit <code>CTRL-c</code> again to exit):</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> cat
<span class="go">Hello world!</span>
<span class="go">Hello world!</span>
<span class="go">^C</span>
</pre></div>


<p>You can use this feature to a couple of useful ends. First, instead of
redirecting one line of output with an <code>echo</code> command, you can use <code>cat</code> to
type several lines (the only catch is that if you make a mistake in an earlier
line, you cannot go back and fix it):</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> cat &gt; thesis.txt
<span class="go">A shell tutorial must</span>
<span class="go">include examples</span>
<span class="go">^C</span>
<span class="gp">wolf:~/learn$</span> cat thesis.txt
<span class="go">A shell tutorial must</span>
<span class="go">include examples</span>
</pre></div>


<p>You can also ask the shell to perform <em>input redirection</em> for you, which takes
the content of a file and provides it as standard input to a program:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> cat &lt; thesis.txt
<span class="go">A shell tutorial must</span>
<span class="go">include examples</span>
</pre></div>


<p>This is a somewhat redundant usage because <code>cat</code> is perfectly willing to take
the filename as argument, but it can come in handy on occasion.</p>
<p>You can use both input and output redirection at the same time, using <code>cat</code> to
essentially perform a file copy:</p>
<div class="highlight"><pre><span class="gp">wolf:~/learn$</span> cat &lt; thesis.txt &gt; thesis2.txt
<span class="gp">wolf:~/learn$</span> cat thesis2.txt
<span class="go">A shell tutorial must</span>
<span class="go">include examples</span>
</pre></div>


<p>This is perhaps no more powerful that the <code>cp</code> command, but consider that <code>cp</code>
cannot be persuaded to <em>append</em> to the destination file, whereas changing the
&gt; to &gt;&gt; in this case will.</p>
<p>Since <code>cat</code> is not trying to manipulate or filter the input on its way to
becoming output, what would really show the power of the concept of redirecting
standard input and output is an expanded collection of tools that <em>do</em> perform
filtering.</p>
<h2 id="grep-print-lines-matching-a-pattern"><code>grep</code> - print lines matching a pattern</h2>
<p>Another extremely useful tool in your shell arsenal is <code>grep</code>, which shows you
the lines from a file that match a given pattern. We can use this to, for
example, look through the list of all users on CDF, which is traditionally
stored in <code>/etc/passwd</code> (the password file.) Let's find all lines from this
file that contain the string "csc":</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> grep csc /etc/passwd
<span class="go">csc108h:x:20507:120:Course csc108h:/u/csc108h:/dev/null</span>
<span class="go">csc148h:x:20511:120:Course csc148h:/u/csc148h:/dev/null</span>
<span class="go">cs108hi:x:21507:1507:Course csc108h:/u/csc108h/cs108hi:/dev/null</span>
<span class="go">cs148hf:x:25061:25061:Course csc148h accessory Fall:/u/csc148h/fall/accessory:/dev/null</span>
<span class="go">cs148hw:x:25062:25062:Course csc148h accessory Winter:/u/csc148h/winter/accessory:/dev/null</span>
<span class="go">cs148hs:x:25063:25063:Course csc148h accessory Summer:/u/csc148h/summer/accessory:/dev/null</span>
<span class="go">cs108hf:x:25181:25181:Course csc108h accessory Fall:/u/csc108h/fall/accessory:/dev/null</span>
<span class="go">cs108hw:x:25182:25182:Course csc108h accessory Winter:/u/csc108h/winter/accessory:/dev/null</span>
<span class="go">cs108hs:x:25183:25183:Course csc108h accessory Summer:/u/csc108h/summer/accessory:/dev/null</span>
<span class="go">... many more ...</span>
</pre></div>


<p>The pattern syntax that <code>grep</code> recognizes are regular expressions, so we can
perform searches that are more sophisticated that just exact strings. For
example, if you run <code>grep '^g[3-5]' /etc/passwd</code>, we will be looking for all
lines that begin with "g" (using the caret "^" to anchor the match to the
beginning of the line), followed by the characters "3", "4" or "5" (using a
range expression.)</p>
<p>If you don't pass <code>grep</code> a filename argument, it will perform its search on the
provided standard input:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> grep csc &lt; /etc/passwd
<span class="go">... matching lines ...</span>
</pre></div>


<h2 id="pipes">Pipes</h2>
<p>We have seen how we can redirect a programs' standard output and save it to a
file, or pass in the contents of a file as standard input.</p>
<p>We can also use a <em>pipe</em> to redirect the output of one program into the input
of another without creating any intermediate file. Simply type two consecutive
commands with the vertical pipe character <code>|</code> between them. For example, we can
chain two calls to grep as follows:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> grep csc /etc/passwd <span class="p">|</span> grep 148
<span class="go">csc148h:x:20511:120:Course csc148h:/u/csc148h:/dev/null</span>
<span class="go">cs148hf:x:25061:25061:Course csc148h accessory Fall:/u/csc148h/fall/accessory:/dev/null</span>
<span class="go">cs148hw:x:25062:25062:Course csc148h accessory Winter:/u/csc148h/winter/accessory:/dev/null</span>
<span class="go">cs148hs:x:25063:25063:Course csc148h accessory Summer:/u/csc148h/summer/accessory:/dev/null</span>
<span class="go">... more ...</span>
</pre></div>


<p>The first invocation of grep returned all the lines of /etc/passwd that
contained the string "csc" anywhere on the line, and the second grep searched
<em>those</em> lines for the further presence of the string "148" and returned any
lines that matched.</p>
<p>Here is another example that uses <code>wc -l</code> to count the number of lines:</p>
<div class="highlight"><pre><span class="gp">wolf:~$</span> grep <span class="s1">&#39;^g[3-5]&#39;</span> /etc/passwd <span class="p">|</span> wc -l
<span class="go">871</span>
</pre></div>


<p>We interpret this output to mean that, within the /etc/passwd file currently on
CDF there are 871 lines that being with either 'g3', 'g4' or 'g5'.</p>
<p>Any program can have its standard output piped into the standard input of any
other program (assuming that program is willing to read from standard input.)
By carefully chaining together several small utilities we can very quickly
formulate and answer everyday questions.</p>
<hr />

        </div>
        <footer class="footer">
            <div class="container">
                <p class="text-muted">&copy; 2015 Karen Reid &amp; Peter McCormick</p>
            </div>
        </footer>
        <script src="../theme/js/jquery-1.11.2.min.js"></script>
        <script src="../theme/js/bootstrap.min.js"></script>
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="../theme/js/ie10-viewport-bug-workaround.js"></script>
    </body>
</html>